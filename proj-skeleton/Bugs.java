

import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;
import java.util.List;
import java.util.Arrays;
import java.io.File;
import java.util.Scanner;
import java.util.Collections;
import java.text.DecimalFormat;

class Bugs {
	public static double T_SUPPORT = 3;
	public static double T_CONFIDENCE = 65;
	public static String filename;

	public static void main(String[] args) {
		//Hashmap that contains our functions and their uses
		Map<String, List<String>> functions = new HashMap<String, List<String>>();
		//Hashmap that contains our accumulated pairs of functions
		Map<List<String>, List<String>> pairs = new HashMap<List<String>, List<String>>();
		//Hashmap that contains our callers
		Map<String, List<String>> callers = new HashMap<String, List<String>>();

		//Analyze the type of input from user
		if(args.length < 1) {
			System.out.println("You need to input bytecode file");
		}
		else {
			filename = args[0];
			if(args.length == 3) {
				T_SUPPORT = Double.parseDouble(args[1]);
				T_CONFIDENCE = Double.parseDouble(args[2]);
			}
		}
		//get the callgraph generated by opt
		String input = readFromFile(filename);
	
		//split our input into lines
		String[] lines = input.split("\n");

		//Get all functions and their callers and put in their places 
		getScopeForFunctions(lines, callers, functions);
		//Generate all pairs of functions and the callers that call the pair
		generatePairs(callers, pairs);
		//Generate bugs by comparing callers of pairs and callers of functions
		generateBugs(pairs, functions);
	}

	public static void generateBugs(Map<List<String>, List<String>> pairs, Map<String, List<String>> functions) {

		double pairSupport = 0;
		double funcSupport = 0;
		String firstKey;
		String secondKey;
		String bug;
		List<String> pairList = new ArrayList<String>();
		List<String> funcList = new ArrayList<String>();

		String bugString = "";

		for(Map.Entry<List<String>, List<String>> entry : pairs.entrySet()) {
			//Is the support of the pair greater or eaqual too T_SUPPORT?
			pairSupport = entry.getValue().size();
			if(pairSupport >= T_SUPPORT) {
				firstKey = entry.getKey().get(0);
				secondKey = entry.getKey().get(1);

				pairList = entry.getValue();

				//First we compare the callers of the first key in the pair, to the callers of the pair and generate bugs
				funcList = functions.get(firstKey);
				funcSupport = funcList.size();
				List<String> temp = new ArrayList<String>(funcList);
				temp.removeAll(pairList);
				DecimalFormat df = new DecimalFormat("#.00");

				double confidence = (pairSupport/funcSupport) * 100;
				if(temp.size() > 0 && confidence >= T_CONFIDENCE && funcSupport >= T_SUPPORT) {
					bug = temp.get(0);
					bugString += "bug: " + firstKey + " in " + bug;
					bugString += ", pair: (" + firstKey + ", " + secondKey + "), ";
					bugString += "support: " + (int) pairSupport + ", confidence: ";
					bugString +=  (df.format(confidence) )  +  "%\n";
				}
				
				//Then we compare the callers of the second key in the pair, to the callers of the pair and generate bugs
				funcList = functions.get(secondKey);
				funcSupport = funcList.size();
				List<String> temp2 = new ArrayList<String>(funcList);
				temp2.removeAll(pairList);
				confidence = (pairSupport/funcSupport) * 100;
				if(temp2.size() > 0 && confidence >= T_CONFIDENCE && funcSupport >= T_SUPPORT) {
					bug = temp2.get(0);
					bugString += "bug: " + secondKey + " in " + bug;
					bugString += ", pair: (" + firstKey + ", " + secondKey + "), ";
					bugString += "support: " + (int) pairSupport + ", confidence: ";
					bugString += df.format(confidence) +  "%\n";
				}
				
			}
		}
		System.out.print(bugString);		
	}
	public static void getScopeForFunctions(String[] lines, Map<String, List<String>> callers, Map<String, List<String>> functions) {
		
		String caller = "";

		for(int i = 1; i < lines.length-1; i++) {
			String[] words = lines[i].split(" ");
			String last = words[words.length -1];
			String callee = "";
			int calls = 0;

			//Get only the lines which contain information about functions and callees and put them in the correct hashmap
			if(lines[i].contains("function") && !(lines[i].contains("null")) && !(lines[i].contains("0x0"))) {
				if(lines[i].startsWith("Call")) {
					caller = lines[i].split("'")[1];
				}
				else {
					callee = last.split("'")[1];
					if(callers.get(caller) == null) {
						List<String> callees = new ArrayList<String>();
						callees.add(callee);
						callers.put(caller, callees);
					}
					else if(!callers.get(caller).contains(callee)) {
							callers.get(caller).add(callee);
					}
					if(functions.get(callee) == null) {
						List<String> func = new ArrayList<String>();
						func.add(caller);
						functions.put(callee, func);
					}
					else if(!functions.get(callee).contains(caller)) {
						functions.get(callee).add(caller);
					}
				}
			}
		}

	}

	public static void generatePairs(Map<String, List<String>> c, Map<List<String>, List<String>> pairs) {
		//Iterate through complete list of callers
		for(Map.Entry<String, List<String>> entry : c.entrySet()) {
			List<String> cList = entry.getValue();
			String caller = entry.getKey();
			if((cList.size() > 1)) {
				//Iterate through the values of each callees of given caller and accumulate a list of pairs
				for(int i = 0; i < cList.size() -1 ; i++) {
					for(int j = i+1; j < cList.size(); j++) {
						List<String> keys = new ArrayList<String>();
						keys.add(cList.get(i)); keys.add(cList.get(j));
						Collections.sort(keys);
						if(pairs.get(keys) == null) {
							List<String> callers = new ArrayList<String>();
							callers.add(caller);
							pairs.put(keys, callers);
						}
						else {
							pairs.get(keys).add(caller);
						}
					}
				}
			}
		}
	}


		public static String readFromFile(String filepath) {
		
		String result = "";
		try {
			File file = new File(filepath);
			Scanner input = new Scanner(file);

			while(input.hasNextLine()){
				String line = input.nextLine() + "\n";
				result += line;
			}
			input.close();
		} catch(Exception ex) {
			ex.printStackTrace();
		}

		return result;
	}
}
